# Data Model: Pet Management CRUD Application

**Feature**: 001-pet-management-crud
**Date**: 2025-10-22
**Database**: PostgreSQL (Supabase)
**ORM**: Prisma

## Overview

This document defines the data model for the pet management application. The schema is designed to support user authentication, pet profile management, and image storage with proper relationships and constraints.

---

## Entity Relationship Diagram

```
┌─────────────────┐         ┌─────────────────┐
│      User       │         │      Pet        │
├─────────────────┤         ├─────────────────┤
│ id (UUID)       │◄───────┤│ id (UUID)       │
│ email           │ 1     * │ user_id (UUID)  │
│ created_at      │         │ name            │
│ updated_at      │         │ category        │
└─────────────────┘         │ birthday        │
                            │ gender          │
                            │ image_path      │
                            │ created_at      │
                            │ updated_at      │
                            └─────────────────┘

Relationship: One User has many Pets
Referential Integrity: CASCADE on delete
```

---

## Entities

### User

Managed by Supabase Auth. Reference only, not created in Prisma schema directly.

**Source**: `auth.users` table (Supabase system table)

**Key Attributes**:
- `id`: UUID, Primary Key (generated by Supabase)
- `email`: String, Unique, Required
- `created_at`: Timestamp
- `updated_at`: Timestamp

**Notes**:
- User data is managed entirely by Supabase Auth
- We reference `auth.users.id` via foreign keys
- Passwords are hashed and stored securely by Supabase

---

### Pet

Represents an animal tracked by a user.

**Table**: `pets`

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, DEFAULT uuid_generate_v4() | Unique identifier |
| `user_id` | UUID | FOREIGN KEY → auth.users(id), NOT NULL, ON DELETE CASCADE | Owner reference |
| `name` | VARCHAR(50) | NOT NULL | Pet's name |
| `category` | VARCHAR(50) | NOT NULL | Type of animal (dog, cat, bird, etc.) |
| `birthday` | DATE | NOT NULL | Pet's date of birth |
| `gender` | VARCHAR(20) | NOT NULL, CHECK IN ('male', 'female', 'other', 'prefer-not-to-say') | Pet's gender |
| `image_path` | TEXT | NULLABLE | Path to image in Supabase Storage |
| `created_at` | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT NOW() | Record creation timestamp |
| `updated_at` | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Indexes**:
- `idx_pets_user_id`: Index on `user_id` (for fast user-specific queries)
- `idx_pets_created_at`: Index on `created_at` (for sorting by newest)

**Constraints**:
- `birthday` must not be in the future
- `name` must be between 1-50 characters
- `category` must not be empty
- `gender` must be one of the allowed values

---

## Prisma Schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Pet {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  name       String   @db.VarChar(50)
  category   String   @db.VarChar(50)
  birthday   DateTime @db.Date
  gender     String   @db.VarChar(20)
  imagePath  String?  @map("image_path") @db.Text
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@index([userId], name: "idx_pets_user_id")
  @@index([createdAt], name: "idx_pets_created_at")
  @@map("pets")
}
```

**Notes**:
- `@db.Uuid`: PostgreSQL UUID type
- `@map("snake_case")`: Database column names use snake_case
- `@@map("pets")`: Table name
- `@updatedAt`: Prisma automatically updates this field
- User relationship is NOT defined in Prisma (Supabase Auth owns users table)

---

## Validation Rules

### Pet Entity

Extracted from functional requirements (FR-010, FR-012, FR-013, FR-020, FR-022):

#### Name
- **Required**: Yes (FR-010, FR-013)
- **Type**: String
- **Min Length**: 1 character
- **Max Length**: 50 characters
- **Validation**: Cannot be empty or whitespace-only
- **Error Message**: "Pet name is required" / "Pet name must be under 50 characters"

#### Category
- **Required**: Yes (FR-010, FR-013)
- **Type**: String (free-text)
- **Min Length**: 1 character
- **Max Length**: 50 characters
- **Examples**: "Dog", "Cat", "Bird", "Rabbit", "Hamster", "Fish"
- **Validation**: Cannot be empty
- **Error Message**: "Pet category is required"

#### Birthday
- **Required**: Yes (FR-010, FR-013)
- **Type**: Date
- **Max Date**: Today (FR-022 - cannot be in the future)
- **Min Date**: January 1, 1900 (reasonable historical bound)
- **Format**: ISO 8601 date (YYYY-MM-DD)
- **Validation**: Must be valid date, not in future, after 1900
- **Error Message**: "Birthday is required" / "Birthday cannot be in the future" / "Please enter a valid birthday"

#### Gender
- **Required**: Yes (FR-010, FR-013)
- **Type**: Enum
- **Allowed Values**:
  - `male`
  - `female`
  - `other`
  - `prefer-not-to-say`
- **Validation**: Must be one of allowed values
- **Error Message**: "Please select a gender"

#### Image
- **Required**: No (optional field)
- **Type**: File upload (JPEG/PNG) stored in Supabase Storage
- **Supported Formats**: JPEG, PNG (FR-012)
- **Max File Size**: 20MB (FR-020)
- **Storage Path**: `{user_id}/pets/{uuid}-{filename}.{ext}`
- **Validation**:
  - File type must be image/jpeg or image/png
  - File size must be ≤ 20MB
  - File must have valid image signature (security)
- **Error Messages**:
  - "Only JPEG and PNG formats are supported"
  - "Image must be under 20MB"
  - "Invalid image file"

---

## Row Level Security (RLS) Policies

Required by FR-018: "System MUST ensure users can only view, edit, or delete their own pets"

### Enable RLS

```sql
ALTER TABLE pets ENABLE ROW LEVEL SECURITY;
```

### Policy: SELECT (Read)

```sql
CREATE POLICY "Users can view own pets"
ON pets
FOR SELECT
TO authenticated
USING (user_id = auth.uid());
```

**Effect**: Users can only see pets where `user_id` matches their authenticated user ID.

### Policy: INSERT (Create)

```sql
CREATE POLICY "Users can create own pets"
ON pets
FOR INSERT
TO authenticated
WITH CHECK (user_id = auth.uid());
```

**Effect**: Users can only insert pets with their own `user_id`.

### Policy: UPDATE (Modify)

```sql
CREATE POLICY "Users can update own pets"
ON pets
FOR UPDATE
TO authenticated
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());
```

**Effect**: Users can only update pets they own, and cannot change ownership.

### Policy: DELETE (Remove)

```sql
CREATE POLICY "Users can delete own pets"
ON pets
FOR DELETE
TO authenticated
USING (user_id = auth.uid());
```

**Effect**: Users can only delete pets they own.

### Storage RLS Policies

```sql
-- Users can upload to their own folder
CREATE POLICY "Users can upload to own folder"
ON storage.objects
FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = 'pet-images'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Users can view their own images
CREATE POLICY "Users can view own images"
ON storage.objects
FOR SELECT
TO authenticated
USING (
  bucket_id = 'pet-images'
  AND (storage.foldername(name))[1] = auth.uid()::text
);

-- Users can delete their own images
CREATE POLICY "Users can delete own images"
ON storage.objects
FOR DELETE
TO authenticated
USING (
  bucket_id = 'pet-images'
  AND (storage.foldername(name))[1] = auth.uid()::text
);
```

---

## State Transitions

### Pet Lifecycle

```
┌─────────────┐
│   Created   │ Initial state when user registers a pet
└──────┬──────┘
       │
       ↓
┌─────────────┐
│   Active    │ Normal state - pet can be viewed/edited
└──────┬──────┘
       │
       ├──→ [Update] → Active (modified data)
       │
       ├──→ [Delete] → Deleted (with confirmation)
       │
       └──→ [Image Upload/Replace] → Active (new image)
```

**State Rules**:
- Pets have no formal state field (always "active" if they exist)
- Deletion is permanent (hard delete, not soft delete)
- Updates preserve `created_at`, update `updated_at`

---

## Data Migration Strategy

### Initial Setup

1. **Supabase Project Setup**:
   - Create Supabase project
   - Enable Authentication (email/password provider)
   - Create storage bucket: `pet-images` (private)

2. **Database Setup**:
   ```bash
   # Initialize Prisma
   npx prisma init

   # Generate migration
   npx prisma migrate dev --name init

   # Generate Prisma Client
   npx prisma generate
   ```

3. **Apply RLS Policies**:
   - Run SQL scripts in Supabase SQL Editor
   - Enable RLS on `pets` table
   - Create all four CRUD policies
   - Create storage policies for `pet-images` bucket

### Seed Data (Development)

```typescript
// prisma/seed.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // Note: Users are managed by Supabase Auth
  // Seed only if you have test users already created

  const testUserId = 'your-test-user-uuid';

  await prisma.pet.createMany({
    data: [
      {
        userId: testUserId,
        name: 'Fluffy',
        category: 'Cat',
        birthday: new Date('2020-05-15'),
        gender: 'female',
      },
      {
        userId: testUserId,
        name: 'Max',
        category: 'Dog',
        birthday: new Date('2019-03-22'),
        gender: 'male',
      },
    ],
  });

  console.log('Seed data created');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

---

## Query Patterns

### Common Queries

**Get all pets for a user (with pagination)**:
```typescript
const pets = await prisma.pet.findMany({
  where: { userId: user.id },
  orderBy: { createdAt: 'desc' },
  take: 20,
  skip: page * 20,
});
```

**Get single pet by ID (ownership verified by RLS)**:
```typescript
const pet = await prisma.pet.findUnique({
  where: { id: petId },
});
// RLS ensures user can only get their own pets
```

**Create pet**:
```typescript
const pet = await prisma.pet.create({
  data: {
    userId: user.id,
    name: 'Fluffy',
    category: 'Cat',
    birthday: new Date('2020-05-15'),
    gender: 'female',
    imagePath: 'user123/pets/uuid-fluffy.jpg',
  },
});
```

**Update pet**:
```typescript
const updated = await prisma.pet.update({
  where: { id: petId },
  data: {
    name: 'Fluffy Jr.',
    imagePath: 'user123/pets/uuid-fluffy-new.jpg',
  },
});
```

**Delete pet**:
```typescript
await prisma.pet.delete({
  where: { id: petId },
});
// Also delete image from storage
await supabase.storage
  .from('pet-images')
  .remove([imagePath]);
```

---

## Performance Considerations

### Indexes

- `idx_pets_user_id`: Critical for filtering pets by user (most common query)
- `idx_pets_created_at`: Enables efficient sorting for "newest first" display

### Query Optimization

- **Pagination**: Limit query results to 20-100 per page (FR requires support for 100 pets)
- **Image Loading**: Use lazy loading for pet images in list view
- **Connection Pooling**: Prisma handles connection pooling automatically
- **Prepared Statements**: Prisma uses prepared statements (SQL injection protection)

### Scalability Targets

From Technical Context:
- Support up to 100 pets per user
- Target: <1000 users initially
- Pet list view: <2 seconds for 100 pets (with indexed queries)
- Database queries: p95 < 100ms (constitution requirement)

---

## Security Considerations

### Data Protection

1. **Row Level Security**: Enforced at database level (cannot be bypassed by application bugs)
2. **Foreign Key Constraints**: Ensure referential integrity with `auth.users`
3. **Input Validation**: All inputs validated both client and server side
4. **SQL Injection Protection**: Prisma uses parameterized queries
5. **Image Security**: Storage RLS prevents unauthorized access

### Privacy

- Email addresses managed by Supabase Auth (not exposed in app database)
- Pet images stored in private buckets with RLS
- No sharing features (FR scope limited to individual user access)

### Compliance

- GDPR considerations: User can delete all pets (cascade delete if user account deleted)
- Data retention: No automatic deletion (user-controlled)
- Audit trail: `created_at` and `updated_at` timestamps on all records

---

## Testing Strategy

### Database Tests

**Unit Tests** (Prisma Client):
- Test CRUD operations
- Test validation constraints
- Test relationships

**Integration Tests** (with Supabase):
- Test RLS policies (verify users cannot access others' pets)
- Test cascade deletes
- Test concurrent updates

**Test Data**:
```typescript
// Test factories
export function createTestPet(overrides = {}) {
  return {
    userId: 'test-user-uuid',
    name: 'Test Pet',
    category: 'Dog',
    birthday: new Date('2020-01-01'),
    gender: 'male',
    ...overrides,
  };
}
```

---

## Summary

**Tables**: 1 application table (`pets`)
**Relationships**: 1 foreign key (Pet → User)
**Indexes**: 2 (user_id, created_at)
**RLS Policies**: 4 for pets table, 3 for storage
**Validation Rules**: 5 fields with specific constraints
**Storage Buckets**: 1 (`pet-images`)

This data model provides:
- ✅ User data isolation via RLS
- ✅ Type-safe queries via Prisma
- ✅ Referential integrity via foreign keys
- ✅ Efficient queries via indexes
- ✅ Secure image storage via Supabase Storage
- ✅ Audit trail via timestamps

All functional requirements (FR-001 through FR-022) are satisfied by this data model.
